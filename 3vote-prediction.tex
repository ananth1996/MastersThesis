\chapter{Vote Prediction}
\label{chp:vote-prediction}
In this chapter, we cover the main motivation behind predicting the vote of an individual voter and present the methods that can be used to solve this task. We discuss the contrast in perspectives that is present when predicting the result compared to predicting a vote in Section~\ref{sec:result-vs-vote}. Next, we explain how the problem of vote prediction is intrinsically linked to the tasks of edge and sign prediction in signed network in Section~\ref{sec:voting-signed-networks}. In Section~\ref{sec:linear-combination-theory}, we describe a supervised machine learning framework that can use graphs features from voting and non-voting data. Lastly, we present our novel approach of constructing a signed graph from neighbours of the current voter and previous votes and using balance and status theory to predict the vote in Section~\ref{sec:local-signed-network}. 


\section{Result versus Vote Prediction}
\label{sec:result-vs-vote}
In this thesis, we are interested in the voting behaviour for a collective action. In such cases, members of a community come together as \textit{voters} to decide on a particular \textit{candidate} item during a \textit{session}. In a government parliament  the voters are the elected members of the parliament and the candidate is usually a bill or policy matter. When it is promotion within a political party or an online community such as Wikipedia, the members vote on a candidate who has been nominated for the position. In all these cases we have two levels of decisions being made. The first the individual decisions that a voter makes with regard to the candidate. The second is the final decision that the group arrives to after everyone has voted. We refer to task of predicting the former as \textit{vote prediction} and the latter as \textit{result prediction}. 

Result prediction provides a macro level perspective of the incentives of a community. We can create models based on the characteristics of a candidate to predict the result of a collective action. This will lead to understanding on a communal level of what features are preferred and if there are voting blocks formed within the members based on the type of candidate. This translates to practical examples such as party level dynamics in a parliament, the topic of a bill or the credentials of a nominee \cite{burke2008mopping,yano2012textual,yogatama-etal-2011-predicting}. 

On the other hand, when we focus on the vote prediction problem, we get a deeper understanding of the dynamics between voters and the candidate. In fields such as game theory, this is well studied using frameworks such as \textit{strategic voting models} and \textit{momentum} \cite{meir2020strategic,zou2015strategicDoodle,ali2006a,banerjee1992simple,tal2015a}. These models are more theoretical and are studied under synthetic conditions. Nevertheless, they still provide a foundation on which we can construct practical models that can utilize additional external features. One such popular approach is using textual information from bills, speeches and legislature to predict votes of politicians in parliament \cite{budhwar2018predicting,gerrish2011predicting}. The next important step is to represent the voting data as networks and leveraging network features to understand and predict voter behaviour.


\section{Voting and Signed networks}
\label{sec:voting-signed-networks}
Votes by nature express a positive or negative relationship between a \textit{voter} and a \textit{candidate}. Therefore, \textit{signed graphs} provide an intuitive way to structurally represent the voting pattern of members in a community. These signed voting networks can be used to develop models to solve the task of vote prediction and analyse voter behaviour.

Correlation clustering and community detection of signed voting graphs can discover trends and vote blocks in communities \cite{brito2020aBrazil,arinik2017signed}. Analysing the networks using social theories of balance and status provides knowledge of voter behaviour and features for prediction methods \cite{levorato2016brazilian,derr2018congressional}. The vote prediction task can be broken down into two subtasks which are analogous to link and sign prediction in signed networks. 

The first subtask is to predict who will vote next given a candidate $c$ and a set of previous votes. This subtask is similar to link prediction in a signed network where we aim to predict possible future edges of the type $(v,c)$. The complexity subtask depends on the format of voting that takes place. If there is a known voting order, such as in roll call in parliamentary proceedings or explicit timestamps then it is essentially solved. If the voting occurs simultaneously, the subtask can be reduced to predicting the possible subset of members who will vote in a given session. When the voting is iterative and there is no known underlying process of who votes next, then a separate model might be required to infer the voting sequence. This case can be combinatorially hard as we would need to find the correct ordering of votes in a session.

The second subtask is to predict how a voter $v$ will vote for a candidate $c$ given the previous votes in the session. This task translates into predicting the sign of an edge $(v,c)$ in the current session. We call this subtask the \textit{independent vote prediction} problem. It is independent in nature are we are only interested in the decision of the voter $v$ assuming that we have complete prior knowledge of how the previous votes have been cast. This problem can be framed as a supervised learning task, using features of the interaction between the current voter $v$, previous voters $U$ and the candidate $c$ to predict the sign of the edge $(v,c)$. We can utilize theories of balance and status in signed networks to create models similar to those by Karimi et al. \cite{karimi2019multicongress} and Jankowski-Lorek et al. \cite{jankowski-lorek2013MBSN} to predict voter behaviour.

\iffalse
\todo[inline]{Are the IC paras neccessary?}
Information cascades are widely studied in epidemiology where we model the spread of a contagion through infections of neighbours and the halting using a rate of recovery. Collective voting in a network can be similarly modelled as a sequence of votes spreading through a network and naturally ending when a final decision has been taken. Using an \textit{independent cascade} model we can separate the spread of information in a network into two logical problems.

The first, is a which node will be affected next. This is equivalent to knowing which node will get infected in a contagion model or which person will be next to vote in a voter model. In contagions spread this is probabilistic hence can be easily modelled. This is different for voting models as some cases might have a fixed voting order while others may not. In the cases we have a known voting order such as the roll call for voting in parliament or timestamps in promotions of Wikipedia administrators, the problem is intrinsically solved. We have mentioned other models above, that can handle cases where there is either no known order or voting happens in a non-sequential manner. 

The second problem, is how will the node will react. In the context of a contagion model, this translates to whether the now infected node becomes sick or not. This is usually a known feature of a given contagion and hence is not critical to a contagion model. In a voter mode, this problem is determining how an individual voter will cast their vote given the information of who have already cast their vote. We call this problem the \textit{independent vote prediction} problem as it considers each voter in the chain as an independent actor and only aims to predict how that particular individual would vote. In solving this problem we can gain insights into the motivations and behaviour of voters. 

The problem of independent vote prediction is studied in Karimi et al. \cite{karimi2019multicongress} and Jankowski-Lorek et al.\cite{jankowski-lorek2013MBSN}. They propose models that incorporate network information, textual data, signed graph features to predict the voting behaviour. Although their models achieve a high predictive accuracy in their respective tasks, they are quite tasks specific and cannot easily be extended to other settings. In contrast, we focus on using general signed network features of balance and status to create a model to predict the votes. 

\fi

\section{Linear Combination of Graphs}
\label{sec:linear-combination-theory}

In this section we explain how the approaches outlined in Section~\ref{sec:link-prediction} can be applied to solve the \textit{independent vote prediction} problem. As discussed previously, the \textit{edge sign prediction} task in signed network is analogous to vote prediction. The models proposed by Leskovec et al. \cite{leskovec2010predicting} can be used to predict the sign of the edge $(v,c)$. Voting in a community takes place across many sessions in a chronological manner. Therefore, we must partition the training and testing datasets to avoid data leakage. We propose the following framework to gather features using a linear combination of the voting history and several auxiliary graphs.

We denote the directed signed graph for the current voting session as $S=(V_S,E_S,w_S)$. The current voter in consideration is denoted by $v$ and the candidate of the session is $c$. In this thesis, for all the models we assume that each session has a unique candidate. The votes that have been cast prior to the current voter exists as edges $(u,c)$ in the session $S$ and the set of prior voters is denoted as $U =\{u \mid (u,c) \in E_S\}$. The history $H=(V_H,E_H,w_H)$ is defined as the directed signed graph containing the votes from sessions chronologically prior to $S$. We also define a set of auxiliary graphs $A = \{G_1,G_2,\dots,G_l\}$ based on external non-voting data. These auxiliary graphs can be either directed or undirected, weighted or unweighted, signed or unsigned. This is similar to the relational layer in \textit{Multidimensional Social Networks} (MSN) described by Kazienko et al. \cite{kazienko2011multidimensional} and Jankowski-Lorek et al. \cite{jankowski-lorek2013MBSN}. However, the auxiliary graphs capture different relations between a subset of the voting members which will be used to generate additional features for the vote prediction task. 

Algorithm~\ref{alg:auxiliary-feature} describes how to generate a feature vector $\mathbf{a}$ from the auxiliary graphs $A$. The algorithm finds the intersection of the prior voters $U$ and the neighbourhood of the current voter $v$ in the graph $G_i$ which we call the \textit{voting neighbourhood}. Then the feature $\mathbf{a}_i$ is computed as the weighted sum of the voting neighbourhood plus the edge weight to the candidate $(v,c)$. Figure~\ref{fig:linear-combination of graphs} provides an example with three auxiliary graphs and two prior voters $u_1$ and $u_2$. The dashed red edges are the votes cast in the current session $S$ by the prior voters. We see that in the example $G_1$ is a directed graph, $G_2$ is an undirected graph and $G_3$ is a signed directed graph. The current voter $v$ has different relations to his voting neighbourhood in each auxiliary graph and therefore each feature is a different combination of edge weights. 

In addition to the auxiliary feature vector $\mathbf{a}$, we can also create triad features based on the historical voting graph $H$. Similar to Leskovec et. al. \cite{leskovec2010predicting} amd Karimi et al. \cite{karimi2019multicongress} we can form a set of unique triads $T$. Then, for each node $u$ in the common neighbourhood of $N_{vc}$ we can count the triad formed from the three vertices. Algorithm~\ref{alg:triad-feature} describes this procedure. 

We can now create a feature matrix $\mathbf{X}$ for all the sessions in a given dataset. Each row is the concatenation of the auxiliary feature vector and the triadic feature vector $\mathbf{x} = [\mathbf{a},\mathbf{t}]$ . The target vector $\mathbf{y}$ is the vector of true votes. Now we train a linear machine learning model and use it to predict the votes in a test dataset.

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Auxiliary feature vector for voter $v$ }
    \label{alg:auxiliary-feature}
    \KwIn{Voter $v$, Candidate $c$, Set of auxiliary graphs $A$, Current voting session $S$ and Prior voters $U$ }
    \KwResult{Auxiliary Feature vector $\mathbf{a}$ }
    Initialize $\mathbf{a}$ of length $|A|$\;
    \ForEach{$G_i$ in $A$}{
     
      $Z = N_i(v) \cap U$ \tcp*{neighbours in $G_i$ who have voted}
      $\mathbf{a}_i \leftarrow 0$\;
      \ForEach{$z$ in $Z$}{
          \tcc{vote in current session multiplied by the edge weight in $G_i$}
          $\mathbf{a}_i$ += $w_S((z,c)) \cdot w_i((v,z))$
      }
      $\mathbf{a}_i += w_i((v,c))$ \tcp*{Add edge weight to candidate}
    }
    \Return $\mathbf{a}$
\end{algorithm}

\begin{figure}[!ht]
    \centering
    \input{images/combination-graphs.tex}
    \caption{Example auxiliary features for $v$ from combination of three graphs and two prior voters $u_1$ and $u_2$. Dashed red lines are prior votes in the session. Solid blue lines are edge weights in auxiliary graph. $\mathbf{a}_i$ is feature for voter $v$ from auxiliary graph $G_i$}
    \label{fig:linear-combination of graphs}
\end{figure}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Triad feature vector for voter $v$ }
    \label{alg:triad-feature}
    \KwIn{Voter $v$, Candidate $c$, Set of unique triads $T$, Voting history graph $H$ }
    \KwResult{Triad Feature vector $\mathbf{t}$ }
    $k \leftarrow |T|$\;
    Initialize counters $cnt_1,\dots,cnt_k$ to 0\;
    $N_{vc} = N_H(v) \cap N_H(c)$ \tcp*{common neighbours in $H$}
    \ForEach{$u$ in $N_{vc}$}{
        Let $\triangle$ be the triad formed by vertices $\{v,u,c\}$ \;
        Classify $\triangle$ as the $j$th triad in $T$ \;
        Increment counter $cnt_j$
    }
    $\mathbf{t} \leftarrow [cnt_1,\dots,cnt_k]$ \;
    \Return $\mathbf{t}$
\end{algorithm}


\section{Local Signed Network}


\label{sec:local-signed-network}

\begin{itemize}
    \item Explain the concept of the local signed network for a particular user
    \item Describe the Session graph $S$ and the historical voting graph $H$. 
    \item Prediction with a session can be iteratively done and at the end update $H$.
    \item Balance is through creating a signed adjacency matrix and then computing the smallest eigenvalue and choosing the edge that makes the graph most balanced. How to report probability that edge is positive.
    \item The status is measured using the concept of agony and in a similar way we choose the edge that has least agony when added.
\end{itemize}


\input{images/local-sign-balance.tex}

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Predict positive vote probability using balance theory}
    \label{alg:balance-pred}
    \KwIn{Voter $v$, Candidate $c$, Local Signed Network $LSN$}
    \KwResult{Probablity of edge $(v,c)$ being positive}
    $w_{LSN}((v,c)) \leftarrow +1$ \tcp*{Assume positive vote}
    Compute signed Laplacian $\overline{L}_+$\;
    $\lambda_1^+ \leftarrow $ smallest eigenvalue of $\overline{L}_+$\;
    $w_{LSN}((v,c)) \leftarrow -1$ \tcp*{Assume negative vote} 
    Compute signed Laplacian $\overline{L}_-$\;
    $\lambda_{1}^- \leftarrow$ smallest eigenvalue of $\overline{L}_-$\;
    $w_{LSN}((v,c)) \leftarrow 0$ \tcp*{Reset edge weight}
    $r \leftarrow {\lambda_{1}^-}/{\lambda_{1}^{+}}$\;
    $p \leftarrow 1/(1+e^{(1-r)})$\;
    \Return p
\end{algorithm}

filler

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Compute Agony for a directed signed network }
    \label{alg:signed-agony}
    \KwIn{Directed siged graph $G = (V,E,w)$}
    \KwResult{Signed Agony $\alpha$ of $G$}
    Initialize $G^\prime = (V^\prime,E^\prime,w^\prime)$\;
    $V^\prime \leftarrow V$\;
    \ForEach{$e \in E$}{
        \eIf{$w(e) <0$}{         
            $e^\prime \leftarrow \left(\dest(e),\src(e)\right)$ \tcp*{Change direction of the edge}
            $E^\prime \leftarrow E^\prime \cup \{e^\prime\} $\;
            $w^\prime(e^\prime)\leftarrow -w(e)$ \tcp*{Make the weight positive}
        }
        {
            $E^\prime \leftarrow E^\prime \cup \{e\}$\;
            $w^\prime(e) \leftarrow w(e)$\;
        }
        
    }
    $\alpha \leftarrow Agony(G^\prime)$\; 
    \Return $\alpha$\;
\end{algorithm}

sdas 

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Predict positive vote probability using status theory}
    \label{alg:status-pred}
    \KwIn{Voter $v$, Candidate $c$, Local Signed Network $LSN$}
    \KwResult{Probablity of edge $(v,c)$ being positive}
    $w_{LSN}((v,c)) \leftarrow +1$ \tcp*{Assume positive vote}
    $\alpha^+ \leftarrow SignedAgony(LSN)$\;
    $w_{LSN}((v,c)) \leftarrow -1$ \tcp*{Assume negative vote} 
    $\alpha^- \leftarrow SignedAgony(LSN)$\;
    $w_{LSN}((v,c)) \leftarrow 0$ \tcp*{Reset edge weight}
    $r \leftarrow {\alpha^-}/{\alpha^{+}}$\;
    $p \leftarrow 1/(1+e^{(1-r)})$\;
    \Return p
\end{algorithm}

filler

\begin{algorithm}[H]
    \DontPrintSemicolon
    \caption{Iterative Balance Model}
    \label{alg:balance-pred}
    \KwIn{Relation graph $R=(V_R,E_R,w_R)$, Order of voters in current session $O$, Candidate $c$ }
    \KwResult{Predictions for current session }
    $k \leftarrow |O|$\;
    $u \leftarrow O[1]$ \tcp*{First voter} 
    $V_S \leftarrow \{c,u\}$ \tcp*{candidate and first voter}
    $E_S \leftarrow \{(u,c)\}$ \tcp*{first vote}
    Add true value of first vote $w_S((u,c))$ \;
    Initialize session graph $S = \{V_S,E_S,w_S\}$\;
    $predictions \leftarrow \emptyset$ \;
    \For{$i \leftarrow 2$ till $|O|$}{
        $v \leftarrow O[i]$\; 
        $V_S \leftarrow V_S \cup \{v\}$ \;
        $LSN \leftarrow S \cap R$\;
        $p \leftarrow Predict(v,c,LSN)$\;
        $predictions \leftarrow predictions \cup p$\;
        $E_S \leftarrow E_S \cup \{(v,c)\}$\;
        Add true value of vote $w_S((v,c))$ \;
    }   
    $Update(R,S)$ \tcp*{Update Relations graph}
    \Return $predictions$\;
\end{algorithm}

\input{images/local-sign-status.tex}